//gamesList.cpp
#include "gamesList.h"
#include "cstddef"
#include <iostream>
gamesL::gamesL()
{
    wins = 0;
    rear = NULL; 
}
gamesL::~gamesL()
{
    wins = 0;
    if(rear)
    {
        removeAll();
    }
}

//needs to be implemented
int gamesL::removeAll()
{
    return removeAll(rear); 
}

//recursively traverse and delete everything
int gamesL::removeAll(gameN * rear)
{
    if(!rear) return 0;
    if(rear)
    {
        gameN * temp = rear->to_next();
        delete rear;
        rear = temp;
    }
    return removeAll(rear);
}


//and to rear
int gamesL::add(game * newN)
{
    //super boring cll insertion algorithmn
    if(!rear) //if empty /base case
    {
        rear = new gameN(newN);  //i think this is using gameN.cpp's upcasting constructor
        rear->to_next() = rear; 
        return 0;
    }
    //if(rear->to_next() == rear) //general case
    //{
        gameN * temp = new gameN(newN);
        temp->to_next() = rear->to_next();
        rear->to_next() = temp;
        rear = temp; //this newly inserted poitner is put into rear
        //temp(newN);
        return 1;
    //}
    //gameN * hold = new gameN(newN);
    //hold->to_next() = rear->to_next();
    //rear->to_next() = hold;
    ////hold(newN);
    //rear = hold;
    //return 1;
}

int gamesL::display()
{
    return display(rear->to_next());
}

int gamesL::display(gameN * curr)
{
    if(curr == rear)
    {
        //a final call
        return 0;
    }

    curr->display();

    return display(curr->to_next());
}

//add the node into the  CLL
//int gamesL::add(gameN * newNode)
//{
//    if(!rear)
//    {
//        rear = new gameN(newNode); //find a way to copy the game into this new node
//        rear->to_next = rear;
//    }
//
//    //0->1
//    //1->2
//    //2+
//}
